//!                      Элементарные типы для графических данных.
/*!
(c) absolutist.com (steps)  2005
******************************************************************************************/
#include "Types.h"

//========================================================================================
//! Отсечение вертикального отрезка p1.X()==p2.X()
//! Предполагается, что вершины прямоугольника упорядочены (r.X1()<r.X2(), r.Y1()<r.Y2())
//
inline  int32 ClipLineVertical(Rect &r, Pixel &p1, Pixel &p2)
{
	if (p1.Y()>p2.Y()) Swap(p1, p2);  // первая точка всегда выше (ось y направлена сверху вниз)
	if (p2.Y()<r.Y1() || p1.Y()>r.Y2()) return 0;
	if (p1.Y()<r.Y1()) p1.Y(r.Y1());
	if (p2.Y()>r.Y2()) p2.Y(r.Y2());
	return p1.X() >= r.X1() && p1.X() <= r.X2();
}
//========================================================================================
//! Отсечение горизонтального отрезка p1.Y()==p2.Y()
// Предполагается, что вершины прямоугольника упорядочены (r.X1()<r.X2(), r.Y1()<r.Y2())
//
inline  int32 ClipLineHorizontal(Rect &r, Pixel &p1, Pixel &p2)
{
	if (p1.X()>p2.X()) Swap(p1, p2);  // первая точка всегда левее
	if (p2.X()<r.X1() || p1.X()>r.X2()) return 0;
	if (p1.X()<r.X1()) p1.X(r.X1());
	if (p2.X()>r.X2()) p2.X(r.X2());
	return p1.Y() >= r.Y1() && p1.Y() <= r.Y2();
}
//========================================================================================
//! В какой квадрат попала точка
// см. Шишкин, Боресков Компьютерная графика, 2000, стр.197 (Алгоритм Сазерленда-Кохена)
// Прямоугольник r разделяет плоскость на 9 частей прямыми проходящими через его стороны.
// 4-х битный код включает бит 0 если точка левее прямоугольника, бит 1 - если правее, 2-выше, 3-ниже
// Предполагается, что вершины прямоугольника упорядочены (r.X1()<r.X2(), r.Y1()<r.Y2())
//
inline int32 PointRectCode(Pixel &p, Rect &r)
{
	int32 res = 0;                                   //   0101 | 0100 | 0110
	if (p.X()<r.X1())  res |= 0x01; // 0001           //   -----|------|-----
	if (p.Y()<r.Y1())  res |= 0x02; // 0010           //   0001 | 0000 | 0010
	if (p.X()>r.X2())  res |= 0x04; // 0100           //   -----|------|-----
	if (p.Y()>r.Y2())  res |= 0x08; // 1000           //   1001 | 1000 | 1010
	return res;
}
//========================================================================================
//! Усечение линии до размеров прямоугольника
// см. Шишкин, Боресков Компьютерная графика, 2000, стр.197 (Алгоритм Сазерленда-Кохена)
// Если некоторый бит кода включён и для начала и для конца отрезка, то он полностью лежит
// вне прямоугольника, иначе последний _может_ отсекать от отрезка кусок
// Если отрезок p1..p2 под наклоном пересекает   p1  *  |
// левую вертикальную сторону в точке p0, то         |\ |
// существует два подобных треугольника,             |_ * p0
// отношение сторон которых приводит к следующей        |
// пропорции:                                           |_* p2
//                                                      |
//   (p0-p1).y   (p2-p1).y                      (p2-p1).y
//   --------- = ---------   =>  p0.y = p1.y +  --------- * (p0-p1).x
//   (p0-p1).x   (p2-p1).x                      (p2-p1).x
//
// Проверки совпадения координат внутри циклв while необходимы, так как даже наклонный
// отрезок после первого отсечения из-за округлений может стать вертикальным или
// горизонтальным, и на втором отсечении получится деление на ноль.
//
int ClipLine(Rect &rect, Pixel &p1, Pixel &p2)
{
	if (p1.X() == p2.X()) return ClipLineVertical(rect, p1, p2); // вертикальный отрезок
	if (p1.Y() == p2.Y()) return ClipLineHorizontal(rect, p1, p2); // горизонтальный отрезок

	int32 code1 = PointRectCode(p1, rect);
	int32 code2 = PointRectCode(p2, rect);
	int32 inside = (code1 | code2) == 0;
	int32 outside = (code1&code2) != 0;

	while (!outside && !inside)
	{
		if (code1 == 0) { Swap(p1, p2); Swap(code1, code2); }

		if (code1 & 0x01) {               // clip left
			if (p2.X() != p1.X())
				p1.Y(p1.Y() + (p2.Y() - p1.Y())*(rect.X1() - p1.X()) / (p2.X() - p1.X()));
			p1.X(rect.X1());
		}
		else if (code1 & 0x02) {               // clip above
			if (p2.Y() != p1.Y())
				p1.X(p1.X() + (p2.X() - p1.X())*(rect.Y1() - p1.Y()) / (p2.Y() - p1.Y()));
			p1.Y(rect.Y1());
		}
		else if (code1 & 0x04) {               // clip right
			if (p2.X() != p1.X())
				p1.Y(p1.Y() + (p2.Y() - p1.Y())*(rect.X2() - p1.X()) / (p2.X() - p1.X()));
			p1.X(rect.X2());
		}
		else if (code1 & 0x08) {               // clip below
			if (p2.Y() != p1.Y())
				p1.X(p1.X() + (p2.X() - p1.X())*(rect.Y2() - p1.Y()) / (p2.Y() - p1.Y()));
			p1.Y(rect.Y2());
		}

		code1 = PointRectCode(p1, rect);
		code2 = PointRectCode(p2, rect);
		inside = (code1 | code2) == 0;
		outside = (code1&code2) != 0;
	}
	return !outside;
}
//========================================================================================
//! Вычисление прямоугольников пересечения des_r, src_r при сдвиге начал их систем координать на dx,dy
//! Результат пересечения при выходе находится в самих прямоугольниках des_r, src_r и приведен в
//! их локальные системы координат. Функция, например используется при копировании прямоугольника
//! src_r битмапа src на битмап des с отсечением des_r, при условии, что левый верхний углы битмапа
//! src сдвинут относительно des на смещение (dx,dy)
//
//! \param des_r - прямоугольник на des в который будет осуществляться копирование
//! \param src_r - прямоугольник на src который будет копироваться в des_r
//! \param dx,dy   - точка на des где будет расположен левый верхний угол копии
//! \return 1 если результирующие прямоугольники не пустые, иначе 0
//
int32 int32ersect(Rect &des_r, Rect &src_r, int32 dx, int32 dy)
{
	src_r.Shift(dx, dy);                     // переносим src в систему координат des
	des_r = src_r = des_r & src_r;           // вычисляем их пересечение
	src_r.Shift(-dx, -dy);                    // возвращаем src в свою систему координат
	return !src_r.Empty() && !src_r.Empty();
}
//========================================================================================
//! Отпозиционировать прямоугольник r1 относительно фиксированного прямоугольника r2 в соответствии с маской.
//! После позиционирования r1 происходит его дополнительный сдвиг на dx, dy.
//! Маска задает различные способы позиционирования r1 отосительно r2 (всего их 100 штук).
//! Первые четыре байта mask соответствуют левой, правой,верхней,нижней сторонам r1, аналогично
//! последнии четыре байта задают стороны прямоугольника r2. Т.е.: mask = 0xL1_R1_T1_B1_L2_R2_T2_B2
//! Например для r1 0xf00000000- левая сторона, 0x0f0000000 правая сторона 0xff000000 центр вдоль х.
//! Примеры масок:
//! * mask = 0x00000000  - только сдвиг относительно левого верехнего угла r2 на dx,dy
//! * mask = 0xf0000f00  - прижать r1 левой  стороной к правой стороне r2 вдоль x
//! * mask = 0x000f000f  - прижать r1 нижней стороной к нижней стороне r2 вдоль y
//! * mask = 0xff00ff00  - отцентрировать r1 относительно r2 вдоль x не меняя y
//! * mask = 0xffffffff  - отцентрировать r1 относительно r2 и по x и по y
//! * mask = 0xf0ff0fff  - прижать r1 левой стороной к правой стороне r2 и отцентрировать r1 по вертикали
//! * mask = 0x00ff000f  - отцентрировать вдоль y прямоугольник r1 относительно нижней стороны прямоугольника r2
//! * ...
//! Прижате тождественых сторон (левая-левая и т.п.) происходит пиксель в пиксель. Левая сторона прижимается
//! к правой в следующем пикселе от стороны
//
Rect & Align(Rect &r1, const Rect &r2, uint32 mask, int32 dx, int32 dy)
{
#define IF(m) if     ((mask & (m)) == (m))
#define OR(m) else if((mask & (m)) == (m))

	int32 w1 = abs(r1.x2 - r1.x1), h1 = abs(r1.y2 - r1.y1), w2 = abs(r2.x2 - r2.x1), h2 = abs(r2.y2 - r2.y1);

	IF(0xff000000) {                                             // центр r1 по x установить:
		IF(0x0000ff00)  r1.MoveToX(r2.x1 + (w2 - w1) / 2);          // в центр r2 по x
		OR(0x0000f000)  r1.MoveToX(r2.x1 - w1 / 2);               // в левую сторону r2
		OR(0x00000f00)  r1.MoveToX(r2.x2 - w1 / 2);               // в правую сторону r2
	}
	OR(0xf0000000) {                                             // левую сторону r1 установить:
		IF(0x0000ff00)  r1.MoveToX(r2.x1 + w2 / 2);               // в центр r2 по x
		OR(0x0000f000)  r1.MoveToX(r2.x1);                      // в левую сторону r2
		OR(0x00000f00)  r1.MoveToX(r2.x2);                      // в правую сторону r2
	}
	OR(0x0f000000) {                                             // правую сторону r1 установить:
		IF(0x0000ff00)  r1.MoveToX(r2.x1 + w2 / 2 - w1);            // в центр r2 по x
		OR(0x0000f000)  r1.MoveToX(r2.x1 - w1);            // в левую сторону r2
		OR(0x00000f00)  r1.MoveToX(r2.x2 - w1);            // в правую сторону r2
	}

	// позиционирование по y независит от позиционирования по х:
	IF(0x00ff0000) {                                             // центр r1 по y установить в:
		IF(0x000000ff)  r1.MoveToY(r2.y1 + (h2 - h1) / 2);          // в центр r2 по y
		OR(0x000000f0)  r1.MoveToY(r2.y1 - h1 / 2);               // в верхнюю сторону r2
		OR(0x0000000f)  r1.MoveToY(r2.y2 - h1 / 2);               // в нижнюю сторону r2
	}
	OR(0x00f00000) {                                             // верхную сторону r1 установить в:
		IF(0x000000ff)  r1.MoveToY(r2.y1 + h2 / 2);               // в центр r2 по y
		OR(0x000000f0)  r1.MoveToY(r2.y1);                      // в верхнюю сторону r2
		OR(0x0000000f)  r1.MoveToY(r2.y2);                      // в нижнюю сторону r2
	}
	OR(0x000f0000) {                                             // нижнюю сторону r1  установить в:
		IF(0x000000ff)  r1.MoveToY(r2.y1 + h2 / 2 - h1);            // в центр r2 по x
		OR(0x000000f0)  r1.MoveToY(r2.y1 - h1);                 // в верхнюю сторону r2
		OR(0x0000000f)  r1.MoveToY(r2.y2 - h1);                 // в нижнюю сторону r2
	}

	r1.Shift(dx, dy);
	return r1;
}
//========================================================================================
//! Разбить прямоугольник r2 по горизонтали на nim_x прямоугольников и применить Align к под-прямоугольнику с номерм k_x=0..num_x-1
//
inline Rect & AlignX(int32 num_x, int32 k_x, Rect &r1, const Rect &r2, uint32 mask, int32 dx, int32 dy)
{
	Rect r(r2);
	int32 w = r.W() / num_x;
	r.X1(r.X1() + w*k_x); r.X2(r.X1() + w);

	return Align(r1, r, mask, dx, dy);
}
//========================================================================================
//! Разбить прямоугольник r2 по вертикале на nim_y частей и применить Align к под-прямоугольнику с номерм k_y=0..num_y-1
//
inline Rect & AlignY(int32 num_y, int32 k_y, Rect &r1, const Rect &r2, uint32 mask, int32 dx, int32 dy)
{
	Rect r(r2);
	int32 h = r.H() / num_y;
	r.Y1(r.Y1() + h*k_y); r.Y2(r.Y1() + h);

	return Align(r1, r, mask, dx, dy);
}
//========================================================================================
//! Разбить прямоугольник r2 по горизонтали на nim_x частей а по вертикале на nim_y частей  и применить Align к под-прямоугольнику с номерм (k_x,k_y)=0..num_x-1
//
inline Rect & AlignXY(int32 num_x, int32 num_y, int32 k_x, int32 k_y, Rect &r1, const Rect &r2, uint32 mask, int32 dx, int32 dy)
{
	Rect r(r2);
	int32 w = r.W() / num_x, h = r.H() / num_y;
	r.X1(r.X1() + w*k_x); r.X2(r.X1() + w);
	r.Y1(r.Y1() + h*k_y); r.Y2(r.Y1() + h);

	return Align(r1, r, mask, dx, dy);
}


void IGMatrix::setIdentity()
{
	m[0][0] = m[1][1] = m[2][2] = 1.0f;
	m[0][1] = m[0][2] = m[1][0] = m[1][2] = m[2][0] = m[2][1] = 0.0f;
	t.x = t.y = t.z = 0.0f;
}

//----------------------------------------------------------------------------------------
//! умножение двух матриц
//
IGMatrix IGMatrix::matMul(IGMatrix const & A, IGMatrix const & B)
{
	static IGMatrix res;

	res.m[0][0] = A.m[0][0] * B.m[0][0] + A.m[0][1] * B.m[1][0] + A.m[0][2] * B.m[2][0];
	res.m[0][1] = A.m[0][0] * B.m[0][1] + A.m[0][1] * B.m[1][1] + A.m[0][2] * B.m[2][1];
	res.m[0][2] = A.m[0][0] * B.m[0][2] + A.m[0][1] * B.m[1][2] + A.m[0][2] * B.m[2][2];

	res.m[1][0] = A.m[1][0] * B.m[0][0] + A.m[1][1] * B.m[1][0] + A.m[1][2] * B.m[2][0];
	res.m[1][1] = A.m[1][0] * B.m[0][1] + A.m[1][1] * B.m[1][1] + A.m[1][2] * B.m[2][1];
	res.m[1][2] = A.m[1][0] * B.m[0][2] + A.m[1][1] * B.m[1][2] + A.m[1][2] * B.m[2][2];

	res.m[2][0] = A.m[2][0] * B.m[0][0] + A.m[2][1] * B.m[1][0] + A.m[2][2] * B.m[2][0];
	res.m[2][1] = A.m[2][0] * B.m[0][1] + A.m[2][1] * B.m[1][1] + A.m[2][2] * B.m[2][1];
	res.m[2][2] = A.m[2][0] * B.m[0][2] + A.m[2][1] * B.m[1][2] + A.m[2][2] * B.m[2][2];


	res.t.x = ((B.m[0][0] * A.t.x) + (B.m[1][0] * A.t.y) + (B.m[2][0] * A.t.z)) + B.t.x;
	res.t.y = ((B.m[0][1] * A.t.x) + (B.m[1][1] * A.t.y) + (B.m[2][1] * A.t.z)) + B.t.y;
	res.t.z = ((B.m[0][2] * A.t.x) + (B.m[1][2] * A.t.y) + (B.m[2][2] * A.t.z)) + B.t.z;

	return res;
}

//----------------------------------------------------------------------------------------
//! умножение матрицы на вектор
//
IGVector3 IGMatrix::matVecMul(IGMatrix const & A, IGVector3 const & V)
{
	IGVector3 res;
	res.x = A.m[0][0] * V.x + A.m[1][0] * V.y + A.m[2][0] * V.z;
	res.y = A.m[0][1] * V.x + A.m[1][1] * V.y + A.m[2][1] * V.z;
	res.z = A.m[0][2] * V.x + A.m[1][2] * V.y + A.m[2][2] * V.z;
	return res;
}


void  IGMatrix::SetRotX(float r/* = 0*/, bool resetTrans/* = true*/, bool setZeros/* = true*/)
{
	if (resetTrans)     t.x = t.y = t.z = 0;
	if (setZeros)       m[0][1] = m[0][2] = m[1][0] = m[2][0] = 0;
	m[0][0] = 1.0f;
	m[1][1] = m[2][2] = (float)cos(r);
	m[1][2] = -(m[2][1] = (float)sin(r));
}

void  IGMatrix::SetRotY(float r/* = 0*/, bool resetTrans/* = true*/, bool setZeros/* = true*/)
{
	if (resetTrans)     t.x = t.y = t.z = 0;
	if (setZeros)       m[0][1] = m[1][2] = m[1][0] = m[2][1] = 0;
	m[1][1] = 1.0f;
	m[0][0] = m[2][2] = (float)cos(r);
	m[2][0] = -(m[0][2] = (float)sin(r));
}

void  IGMatrix::SetRotZ(float r/* = 0*/, bool resetTrans/* = true*/, bool setZeros/* = true*/)
{
	if (resetTrans)     t.x = t.y = t.z = 0;
	if (setZeros)       m[0][2] = m[1][2] = m[2][0] = m[2][1] = 0;
	m[2][2] = 1.0f;
	m[0][0] = m[1][1] = (float)cos(r);
	m[0][1] = -(m[1][0] = (float)sin(r));
}
//========================================================================================

